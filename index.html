<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Pacman Renard ‚Äî 4 labyrinthes</title>
<style>
  body { background:#000; margin:0; font-family:monospace; color:#fff; text-align:center; user-select:none; }
  #game-container { display:inline-block; position:relative; }
  canvas { background:#ccc; display:block; margin:0 auto; image-rendering:pixelated; }
  #score { margin:8px 0; }
  #controls { margin:10px 0 6px; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
  label { opacity:.9; }
  input, select, button { font-size:16px; padding:6px 10px; }
  #timer { font-size:20px; margin:6px 0 10px; font-weight:bold; }
</style>
</head>
<body>

<!-- Contr√¥les -->
<div id="controls">
  <label for="scale">Zoom :</label>
  <input type="number" id="scale" value="47" min="16" max="64" step="4" /> // Value = Zoom par defaut
  <label for="ghostCount">Fant√¥mes (2‚Äì5) :</label>
  <select id="ghostCount">
    <option value="2">2</option>
    <option value="3" selected>3</option>
    <option value="4">4</option>
    <option value="5">5</option>
  </select>
  <button id="startBtn">D√©marrer</button>
</div>

<div id="timer">Temps restant : 01:30</div>
<div id="MaJ">!! Mis √† jour le 16/08/25 !!</div>
<div id="score">Score : 0 | Vies : 4</div>
<div id="game-container">
  <canvas id="game"></canvas>
</div>

<script>
/* =======================
   PARAM√àTRES MODIFIABLES
   ======================= */
const PLAYER_SPEED     = 160;   // px par frame (joueur)
const GHOST_SPEED      = 6;    // px par frame (fant√¥mes)
const FROG_SPAWN_RATE  = 99;   // % de cases libres qui contiennent une grenouille (0‚Äì100)
const LEVEL_TIME       = 90;  // secondes par labyrinthe
const DEFAULT_NUM_GHOSTS = 3;  // nombre par d√©faut (sera √©cras√© par le s√©lecteur UI)
const WALL_HITS_REQUIRED = 3; // nombre de coups n√©cessaires pour casser un mur
  
/* =======================
   LABYRINTHES (15 x 14)
   1 = mur, 0 = chemin (grenouille potentielle), 2 = vide, 3 = mur cassable (optionnel)
   ======================= */
const labyrinths = [
  [ // 1
    [3, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
    [1, 0, 3, 1, 3, 0, 0, 0, 1, 3, 3, 1, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 3, 1, 1, 3, 0, 1],
    [1, 0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 3, 1, 0, 3, 0, 1],
    [1, 0, 3, 1, 3, 0, 0, 0, 1, 0, 0, 1, 0, 1],
    [1, 0, 1, 3, 1, 0, 0, 0, 3, 0, 0, 3, 0, 1],
    [1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 3, 1, 0, 0, 0, 1, 3, 3, 1, 0, 1],
    [1, 0, 3, 1, 3, 0, 0, 0, 3, 1, 1, 3, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 3, 1, 3, 0, 0, 0, 3, 0, 3, 1, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1],
    [1, 0, 3, 1, 3, 0, 0, 0, 3, 1, 1, 3, 0, 1],
    [3, 1, 1, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 3],
  ],
  [ // 2
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,1,0,0,3,0,1,0,1],
    [1,0,1,1,1,0,1,0,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,0,1,0,1],
    [1,1,1,0,1,1,1,0,1,0,1,1,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,1,1,1,0,1,1,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,1,1,1,1,1,0,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1,1,1,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [ // 3
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,1,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,0,1,0,1],
    [1,1,1,0,1,1,1,1,1,0,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,0,1,1,1,1,1,1,1,0,1,0,1,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,1],
    [1,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,1,1,1,1,1,0,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1,1,1,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [ // 4
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,1,0,1,0,1],
    [1,1,1,0,1,0,1,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,1,1,1,0,1,1,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,1,1,1,1,1,0,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1,1,1,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
];

const rows = 15, cols = 14;

/* =======================
   R√âF√âRENCES DOM & √âTAT
   ======================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const startBtn = document.getElementById('startBtn');
const scaleInput = document.getElementById('scale');
const ghostCountSel = document.getElementById('ghostCount');


let scale = parseInt(scaleInput.value);
let labyrinth = [];
let damageMap = {};
let score = 0;
let lives = 4;
let respawning = false;
let gameInterval = null;
let gameRunning = false;
let timerInterval = null;
let timeRemaining = LEVEL_TIME;
let currentLabIndex = 0;

const player = { x:1, y:1, xPos:1*scale, yPos:1*scale, dir:null, moving:false };
let ghosts = []; // g√©n√©r√© dynamiquement

// Images
const imgRenard = new Image();
const imgGrenouille = new Image();
imgRenard.src   = 'https://png.pngtree.com/png-vector/20240814/ourmid/pngtree-realistic-fox-head-illustration-png-image_13481187.png';
imgGrenouille.src = 'https://png.pngtree.com/png-vector/20250109/ourlarge/pngtree-realistic-green-frog-with-smooth-skin-and-lifelike-texture-png-image_15076823.png';

alert("Bienvenue dans le jeu ! OBJECTIF : \nManger toutes les grenouilles sur 4 niveaux !. \n‚ù§Ô∏èüñ§");
  
/* =======================
   OUTILS
   ======================= */
function resizeCanvas() {
  canvas.width = cols * scale;
  canvas.height = rows * scale;
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';
}

function canMove(x, y) {
  if (!labyrinth[y] || labyrinth[y][x] == null) return false;
  const t = labyrinth[y][x];
  return (t !== 1); // les murs classiques bloquent, mais pas les murs cassables
}

function updateScore() {
  scoreEl.textContent = `Score : ${score} | Vies : ${lives}`;
}

function formatTime(seconds) {
  const m = Math.floor(seconds/60);
  const s = seconds % 60;
  return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
}

/* =======================
   G√âN√âRATION NIVEAUX & ENTIT√âS
   ======================= */
function generateLabyrinth() {
  labyrinth = [];
  damageMap = {};

  // Copie du mod√®le courant
  const base = labyrinths[currentLabIndex];
  for (let r=0; r<rows; r++) {
    labyrinth[r] = [];
    for (let c=0; c<cols; c++) labyrinth[r][c] = base[r][c];
  }

  // Zone d√©part d√©gag√©e
  labyrinth[1][1] = 0; labyrinth[1][2] = 0; labyrinth[2][1] = 0;
  labyrinth[2][2] = 0; labyrinth[2][3] = 0; labyrinth[3][1] = 0;

  // Placement grenouilles selon FROG_SPAWN_RATE %
  for (let r=1; r<rows-1; r++) {
    for (let c=1; c<cols-1; c++) {
      if (labyrinth[r][c] === 0) {
        labyrinth[r][c] = (Math.random()*100 < FROG_SPAWN_RATE) ? 0 : 2;
      }
    }
  }

  resetPlayer();
  generateGhosts();
}

  function hitWall(x, y) {
  const key = `${x},${y}`;
  if (!damageMap[key]) damageMap[key] = 0;
  damageMap[key]++;

  // changer le tile selon les coups
  if (damageMap[key] === 1) labyrinth[y][x] = 4;       // 1er coup ‚Üí noir
  else if (damageMap[key] === 2) labyrinth[y][x] = 5;  // 2e coup ‚Üí orange
  else if (damageMap[key] >= WALL_HITS_REQUIRED) {
    labyrinth[y][x] = 2; // mur cass√© ‚Üí fond
    delete damageMap[key];

    // effet visuel (optionnel)
    effects.push({x, y, duration: 10, color: '#fff'});
  }
}

function resetPlayer() {
  player.x = 1; player.y = 1;
  player.xPos = player.x * scale;
  player.yPos = player.y * scale;
  player.dir = null;
  player.moving = false;
}

function generateGhosts() {
  const wanted = clamp(parseInt(ghostCountSel.value || DEFAULT_NUM_GHOSTS), 2, 5);
  ghosts = [];

  // Palette (pas de vert)
  const palette = ['red', 'black', 'blue', 'orange', 'magenta', 'purple', 'yellow'];
  // Spawns propos√©s (essaye coins & zones)
  const spawns = [
    {x: cols-2, y: 1},
    {x: cols-2, y: rows-2},
    {x: 1,      y: rows-2},
    {x: Math.floor(cols/2), y: Math.floor(rows/2)},
    {x: cols-2, y: Math.floor(rows/2)}
  ];

  for (let i=0; i<wanted; i++) {
    const spawn = spawns[i % spawns.length];
    let gx = spawn.x, gy = spawn.y;
    // si case bloqu√©e, recule jusqu'√† trouver du libre (petit balayage)
    let tries = 0;
    while (!canMove(gx, gy) && tries < 30) {
      gx = Math.max(1, Math.min(cols-2, gx + (Math.random()<0.5?-1:1)));
      gy = Math.max(1, Math.min(rows-2, gy + (Math.random()<0.5?-1:1)));
      tries++;
    }
    ghosts.push({
      x: gx, y: gy,
      xPos: gx*scale, yPos: gy*scale,
      dir: 'left',
      color: palette[i % palette.length],
      moving: false
    });
  }
}

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* =======================
   DESSIN
   ======================= */
function drawLabyrinth() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const t = labyrinth[r][c];

      if (t === 1) {          // mur normal
        ctx.fillStyle = '#800000';
        ctx.fillRect(c*scale, r*scale, scale, scale);
      } 
      else if (t === 3) {     // mur cassable initial
        ctx.fillStyle = '#000';
        ctx.fillRect(c*scale, r*scale, scale, scale);
      } 
      else if (t === 4) {     // 1er coup
        ctx.fillStyle = 'red';
        ctx.fillRect(c*scale, r*scale, scale, scale);
      } 
      else if (t === 5) {     // 2e coup
        ctx.fillStyle = 'orange';
        ctx.fillRect(c*scale, r*scale, scale, scale);
      } 
      else if (t === 0) {     // grenouille
        if (imgGrenouille.complete) {
          ctx.drawImage(imgGrenouille, c*scale + scale*0.1, r*scale + scale*0.1, scale*0.8, scale*0.8);
        }
      } 
      else if (t === 2) {     // vide / fond
        ctx.fillStyle = '#ccc';
        ctx.fillRect(c*scale, r*scale, scale, scale);
      }
    }
  }
}

function drawPlayer() {
  if (imgRenard.complete) {
    ctx.drawImage(imgRenard, player.xPos, player.yPos, scale, scale);
  } else {
    ctx.fillStyle = '#ff6600';
    ctx.beginPath();
    ctx.arc(player.xPos + scale/2, player.yPos + scale/2, scale/2 - 4, 0, Math.PI*2);
    ctx.fill();
  }
}

function drawGhosts() {
  ghosts.forEach(g => {
    const gx = g.xPos + scale/2;
    const gy = g.yPos + scale/2;
    ctx.fillStyle = g.color;
    ctx.beginPath();
    ctx.arc(gx, gy, scale/2 - 4, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.floor(scale/2)}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('R2', gx, gy);
  });
}

/* =======================
   LOGIQUE
   ======================= */
function countRemainingFrogs() {
  let n=0;
  for (let r=0; r<rows; r++)
    for (let c=0; c<cols; c++)
      if (labyrinth[r][c] === 0) n++;
  return n;
}

function movePlayer() {
  if (!player.moving) return;
  const tx = player.x * scale;
  const ty = player.y * scale;

  if (player.xPos < tx) { player.xPos += PLAYER_SPEED; if (player.xPos > tx) player.xPos = tx; }
  else if (player.xPos > tx) { player.xPos -= PLAYER_SPEED; if (player.xPos < tx) player.xPos = tx; }

  if (player.yPos < ty) { player.yPos += PLAYER_SPEED; if (player.yPos > ty) player.yPos = ty; }
  else if (player.yPos > ty) { player.yPos -= PLAYER_SPEED; if (player.yPos < ty) player.yPos = ty; }

  if (player.xPos === tx && player.yPos === ty) {
    player.moving = false;
    // mange grenouille
    if (labyrinth[player.y][player.x] === 0) {
      labyrinth[player.y][player.x] = 2;
      score++;
      updateScore();
    }
  }
}

function moveGhosts() {
  ghosts.forEach(g => {
    if (g.moving) {
      const tx = g.x * scale, ty = g.y * scale;

      if (g.xPos < tx) { g.xPos += GHOST_SPEED; if (g.xPos > tx) g.xPos = tx; }
      else if (g.xPos > tx) { g.xPos -= GHOST_SPEED; if (g.xPos < tx) g.xPos = tx; }

      if (g.yPos < ty) { g.yPos += GHOST_SPEED; if (g.yPos > ty) g.yPos = ty; }
      else if (g.yPos > ty) { g.yPos -= GHOST_SPEED; if (g.yPos < ty) g.yPos = ty; }

      if (g.xPos === tx && g.yPos === ty) g.moving = false;
    } else {
      const dirs = ['left','right','up','down'];
      let options = dirs.filter(d => {
        let nx=g.x, ny=g.y;
        if (d==='left') nx--; else if (d==='right') nx++;
        else if (d==='up') ny--; else if (d==='down') ny++;
        return canMove(nx, ny);
      });

      if (options.length > 1) {
        const opp = {left:'right', right:'left', up:'down', down:'up'};
        options = options.filter(d => d !== opp[g.dir]);
        if (options.length === 0) options = dirs;
      }

      if (options.length) {
        g.dir = options[Math.floor(Math.random()*options.length)];
        if (g.dir==='left') g.x--;
        else if (g.dir==='right') g.x++;
        else if (g.dir==='up') g.y--;
        else if (g.dir==='down') g.y++;
        g.moving = true;
      }
    }
  });
}

function checkCollision() {
  if (respawning) return;  // ignore les collisions pendant le respawn

  for (const g of ghosts) {
    if (Math.abs(g.xPos - player.xPos) < scale*0.5 &&
        Math.abs(g.yPos - player.yPos) < scale*0.5) {
      lives--;
      updateScore();
      if (lives <= 0) {
        gameOver("Game Over ! Vous avez perdu toutes vos vies.");
      } else {
        respawning = true;   // active invincibilit√© temporaire
        player.moving = false;
        gameRunning = false;

        setTimeout(() => {
          resetPlayer();
          respawning = false;
          gameRunning = true;
        }, 2000); // d√©lai 2 secondes avant respawn
      }
      return;
    }
  }
}

function startTimer() {
  timeRemaining = LEVEL_TIME;
  timerEl.textContent = `Temps restant : ${formatTime(timeRemaining)}`;
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    timeRemaining--;
    timerEl.textContent = `Temps restant : ${formatTime(timeRemaining)}`;
    if (timeRemaining <= 0) {
      clearInterval(timerInterval);
      gameOver("Temps √©coul√© ! Fin de la partie.");
    }
  }, 1000);
}

function stopTimer(){ if (timerInterval) clearInterval(timerInterval); }

function showVictory(msg, onOk){
  stopTimer();
  gameRunning = false;
  if (gameInterval) clearInterval(gameInterval);
  if (confirm(msg)) onOk();
}

function nextLabyrinth() {
  currentLabIndex++;
  if (currentLabIndex >= labyrinths.length) {
    alert("F√©licitations ! Vous avez termin√© les 4 labyrinthes !");
    gameRunning = false;
    clearInterval(gameInterval);
    stopTimer();
    return;
  }
  // on conserve score & vies comme dans ta version pr√©c√©dente ? Ici on conserve.
  generateLabyrinth();
  startTimer();
  startLoop();
}

/* =======================
   BOUCLE DE JEU
   ======================= */
function update() {
  movePlayer();
  moveGhosts();
  checkCollision();

  if (countRemainingFrogs() === 0) {
    showVictory(`Labyrinthe ${currentLabIndex+1} termin√© ! Tu as mang√© toutes les grenouilles !! Cliquez sur OK pour continuer.`, nextLabyrinth);
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawLabyrinth();
  drawPlayer();
  drawGhosts();
}

function startLoop() {
  if (gameInterval) clearInterval(gameInterval);
  gameRunning = true;
  gameInterval = setInterval(() => { update(); draw(); }, 30);
}

function gameOver(message) {
  stopTimer();
  gameRunning = false;
  clearInterval(gameInterval);
  alert(message);
}

/* =======================
   CONTROLES
   ======================= */
function handleKeyDown(e) {
  if (!gameRunning || player.moving) return;

  let nx = player.x, ny = player.y;
  if (e.key === 'ArrowLeft') nx--;
  else if (e.key === 'ArrowRight') nx++;
  else if (e.key === 'ArrowUp') ny--;
  else if (e.key === 'ArrowDown') ny++;
  else return;

  if (!labyrinth[ny] || labyrinth[ny][nx] == null) return;

  const tile = labyrinth[ny][nx];

  if (tile === 1) return; // mur classique : bloqu√©

  if (tile === 3 || tile === 4 || tile === 5) { // mur cassable
    hitWall(nx, ny); 
    // Bloque le joueur jusqu'√† ce que le mur soit d√©truit
    if (labyrinth[ny][nx] !== 2) return;
  }

  // D√©placement du joueur autoris√©
  player.x = nx;
  player.y = ny;
  player.moving = true;
  player.dir = e.key.replace('Arrow','').toLowerCase();
}

function startGame() {
  scale = parseInt(scaleInput.value) || 40;
  resizeCanvas();
  currentLabIndex = 0;
  score = 0;
  lives = 3;
  updateScore();
  generateLabyrinth();
  startTimer();
  startLoop();
}

/* =======================
   INIT
   ======================= */
window.addEventListener('keydown', handleKeyDown);
startBtn.addEventListener('click', () => {
  if (!gameRunning) startGame();
});

resizeCanvas();
updateScore();
timerEl.textContent = `Temps restant : ${formatTime(LEVEL_TIME)}`;

</script>
</body>
</html>
